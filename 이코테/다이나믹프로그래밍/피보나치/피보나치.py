# 다이나믹 프로그래밍이란 동적계획법이라고도 표현한다.
# 메모리 공간을 더 사용하고 연산 속도를 비약적으로 증가시키는 방법.
# 탑다운(메모이제이션(캐싱)기법), 바텀업

# 재귀함수 사용, 이건 O(2^n) 시간복잡도
def fibo(x):
    if x == 1 or x == 2:
        return 1
    return fibo(x-1) + fibo(x-2)

print(fibo(4))

# 이렇게하면 죽을때까지 계산해도 못함 -> 그래서 dp를 활용
# 큰 문제를 작은 문제로 나눌 수 있다.
# 작은 문제에서 구한 정답은 그것을 포함하는 큰 문제에서도 동일하다.
# 이 2가지 조건이 만족되어야만 다이나믹 프로그래밍을 사용할 수 있다.
# 근데 작은 문제를 나누는 법은 퀵정렬에서도 소개된 적 있다.
# 이를 분할정복 알고리즘이라고 함
# dp와 분할정복의 차이점은 dp는 문제들이 서로 영향을 미치고 있다는 점.

# 메모이제이션 기법(=탑다운), 이건 O(N)의 시간복잡도, 배열,딕셔너리로 구현 가능
# 큰 문제를 작은 문제로 나눈다고 해서.
dp = [0]*100
def fibo(x):
    if x == 1 or x == 2:
        return 1   
    if dp[x] != 0:
        return dp[x]
    dp[x] = fibo(x-1) + fibo(x-2)
    return dp[x]

print(fibo(99))

# 바텀업 방식, 이게 더 권장하는 방식, 반복문 이용
# 시스템상 재귀 함수의 스택 크기가 한정되어 있을 수도 있기 때문
# recursion depth 에러 생각하면 됨
# 이거 sys에있는 setrecursionlimit() 함수 호출로 해결할 수 있긴 함 - 파이썬의 기본 깊이 제한은 약 1000번
# sys.setrecursionlimit(10**6) 이런식으로 해결함
dp = [0]*100
dp[1] = 1
dp[2] = 1
n = 99
for i in range(3, n+1):
    dp[i] = dp[i-1] + dp[i-2]

print(dp[99])